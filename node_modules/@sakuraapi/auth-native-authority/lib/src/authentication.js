"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@sakuraapi/core");
const bcrypt_1 = require("bcrypt");
const crypto_1 = require("crypto");
const jsonwebtoken_1 = require("jsonwebtoken");
const mongodb_1 = require("mongodb");
const urlsafe_base64_1 = require("urlsafe-base64");
const uuid_1 = require("uuid");
const pwStrength = require("zxcvbn");
const IV_LENGTH = 16;
function addAuthenticationAuthority(sapi, options) {
    const endpoints = options.endpoints || {};
    if (!sapi) {
        throw new Error('auth-native-authority must have a valid instance of SakuraApi');
    }
    if (!options.userDbConfig || !options.userDbConfig.db || !options.userDbConfig.collection) {
        throw new Error('auth-native-authority addAuthenticationAuthority options parameter must have a valid ' +
            `'userDbConfig' configuration in 'IAuthenticationAuthorityOptions. Provided options ${JSON.stringify(options)}`);
    }
    const nativeAuthConfig = ((sapi.config.authentication || {}).native || null);
    const jwtAuthConfig = (sapi.config.authentication || {}).jwt || null;
    if (!nativeAuthConfig) {
        throw new Error('auth-native-authority requires SakuraApi\'s configuration to have ' +
            '`authentication.native` set.');
    }
    if (!jwtAuthConfig) {
        throw new Error('auth-native-authority requires SakuraApi\'s configuration to have `authentication.jwt` set.');
    }
    if (!jwtAuthConfig.key) {
        throw new Error('auth-native-authority requires SakuraApi\'s configuration to have `authentication.jwt.key` set ' +
            'to a valid AES 256 private key');
    }
    if (jwtAuthConfig.key.length !== 32) {
        throw new Error('auth-native-authority requires SakuraApi\'s configuration\'s `authentication.jwt.key` to be ' +
            `be 32 characters long. The provided key is ${jwtAuthConfig.key.length} characters long`);
    }
    const bcryptHashRounds = options.bcryptHashRounds || nativeAuthConfig.bcryptHashRounds || 12;
    const fields = {
        domainDb: ((options.model || {}).domain || {}).dbField
            || ((nativeAuthConfig.model || {}).domain || {}).dbField
            || 'domain',
        domainJson: ((options.model || {}).domain || {}).jsonField
            || ((nativeAuthConfig.model || {}).domain || {}).jsonField
            || 'domain',
        emailDb: ((options.model || {}).email || {}).dbField
            || ((nativeAuthConfig.model || {}).email || {}).dbField
            || 'email',
        emailJson: ((options.model || {}).email || {}).jsonField
            || ((nativeAuthConfig.model || {}).email || {}).jsonField
            || 'email',
        emailVerifiedDb: ((options.model || {}).emailVerified || {}).dbField
            || ((nativeAuthConfig.model || {}).emailVerified || {}).dbField
            || 'emailVerified',
        emailVerifiedJson: ((options.model || {}).emailVerified || {}).jsonField
            || ((nativeAuthConfig.model || {}).emailVerified || {}).jsonField
            || 'emailVerified',
        lastLoginDb: ((options.model || {}).passwordResetHash || {}).dbField
            || ((nativeAuthConfig.model || {}).passwordResetHash || {}).dbField
            || 'lastLogin',
        passwordDb: ((options.model || {}).password || {}).dbField
            || ((nativeAuthConfig.model || {}).password || {}).dbField
            || 'pw',
        passwordResetHashDb: ((options.model || {}).passwordResetHash || {}).dbField
            || ((nativeAuthConfig.model || {}).passwordResetHash || {}).dbField
            || 'pwResetId',
        passwordSetDateDb: ((options.model || {}).password || {}).dbField
            || ((nativeAuthConfig.model || {}).password || {}).dbField
            || 'pwSet',
        passwordStrengthDb: ((options.model || {}).passwordStrength || {}).dbField
            || ((nativeAuthConfig.model || {}).passwordStrength || {}).dbField
            || 'pwStrength'
    };
    let NativeAuthenticationAuthorityUser = class NativeAuthenticationAuthorityUser extends core_1.SapiModelMixin() {
        constructor() {
            super(...arguments);
            this.domain = options.defaultDomain || nativeAuthConfig.defaultDomain || undefined;
            this.passwordSet = new Date();
            this.emailVerified = false;
        }
    };
    __decorate([
        core_1.Db(fields.emailDb), core_1.Json(fields.emailJson),
        __metadata("design:type", String)
    ], NativeAuthenticationAuthorityUser.prototype, "email", void 0);
    __decorate([
        core_1.Db(fields.domainDb), core_1.Json(fields.domainJson),
        __metadata("design:type", String)
    ], NativeAuthenticationAuthorityUser.prototype, "domain", void 0);
    __decorate([
        core_1.Db({ field: fields.passwordDb, private: true }),
        __metadata("design:type", String)
    ], NativeAuthenticationAuthorityUser.prototype, "password", void 0);
    __decorate([
        core_1.Db({ field: fields.passwordSetDateDb }),
        __metadata("design:type", Object)
    ], NativeAuthenticationAuthorityUser.prototype, "passwordSet", void 0);
    __decorate([
        core_1.Db({ field: fields.passwordStrengthDb }),
        __metadata("design:type", Number)
    ], NativeAuthenticationAuthorityUser.prototype, "passwordStrength", void 0);
    __decorate([
        core_1.Db(fields.emailVerifiedDb), core_1.Json(fields.emailVerifiedJson),
        __metadata("design:type", Object)
    ], NativeAuthenticationAuthorityUser.prototype, "emailVerified", void 0);
    NativeAuthenticationAuthorityUser = __decorate([
        core_1.Model({
            dbConfig: {
                collection: options.userDbConfig.collection,
                db: options.userDbConfig.db,
                promiscuous: true
            }
        })
    ], NativeAuthenticationAuthorityUser);
    let AuthenticationLog = class AuthenticationLog extends core_1.SapiModelMixin() {
        constructor() {
            super(...arguments);
            this.authType = 'native';
            this.ip = '';
            this.port = null;
            this.url = '';
            this.hostName = '';
            this.invalidated = false;
            this.audience = [];
        }
    };
    __decorate([
        core_1.Db('uid'), core_1.Json(),
        __metadata("design:type", mongodb_1.ObjectID)
    ], AuthenticationLog.prototype, "userId", void 0);
    __decorate([
        core_1.Db('jti'), core_1.Json(),
        __metadata("design:type", String)
    ], AuthenticationLog.prototype, "jwTokenId", void 0);
    __decorate([
        core_1.Db('tkn'), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "token", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "created", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "authType", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "ip", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "port", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "url", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "hostName", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Object)
    ], AuthenticationLog.prototype, "invalidated", void 0);
    __decorate([
        core_1.Db(), core_1.Json(),
        __metadata("design:type", Array)
    ], AuthenticationLog.prototype, "audience", void 0);
    AuthenticationLog = __decorate([
        core_1.Model({
            dbConfig: {
                collection: options.authDbConfig.collection,
                db: options.authDbConfig.db,
                promiscuous: true
            }
        })
    ], AuthenticationLog);
    let AuthenticationAuthorityApi = class AuthenticationAuthorityApi extends core_1.SapiRoutableMixin() {
        changePassword(req, res, next) {
            const locals = res.locals;
            const email = `${locals.reqBody.email}`;
            const currentPassword = `${locals.reqBody.currentPassword}`;
            const newPassword = `${locals.reqBody.newPassword}`;
            const domain = `${locals.reqBody.domain || options.defaultDomain || nativeAuthConfig.defaultDomain}`;
            let user;
            Promise
                .resolve()
                .then(() => {
                if (!locals.reqBody.email || !locals.reqBody.currentPassword || !locals.reqBody.newPassword) {
                    locals.send(400, { error: 'invalid_body' });
                    throw 400;
                }
                const query = {
                    [fields.emailDb]: email,
                    [fields.domainDb]: domain
                };
                return NativeAuthenticationAuthorityUser.getOne(query);
            })
                .then((usr) => {
                user = usr;
                if (!user) {
                    locals.send(401, { error: 'unauthorized' });
                    throw 401;
                }
            })
                .then(() => bcrypt_1.compare(currentPassword, user.password))
                .then((pwMatch) => {
                if (!pwMatch) {
                    locals.send(401, { error: 'unauthorized' });
                    throw 401;
                }
            })
                .then(() => bcrypt_1.hash(newPassword, bcryptHashRounds))
                .then((pwHash) => {
                return user.save({
                    [fields.passwordDb]: pwHash,
                    [fields.passwordSetDateDb]: new Date(),
                    [fields.passwordStrengthDb]: this.getPasswordStrength(newPassword, user)
                });
            })
                .then(() => (options.onChangePasswordEmailRequest)
                ? options.onChangePasswordEmailRequest(user, req, res)
                : Promise.resolve())
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err === 400 || err === 401) {
                    return next();
                }
                if (options.onError) {
                    yield options.onError(err);
                }
                next();
            }));
        }
        create(req, res, next) {
            const locals = res.locals;
            const customFields = (options.create || {}).acceptFields
                || (((sapi.config.authentication || {}).native || {}).create || {}).acceptFields;
            const email = `${locals.reqBody.email}`;
            const password = `${locals.reqBody.password}`;
            const domain = `${locals.reqBody.domain || options.defaultDomain || nativeAuthConfig.defaultDomain}`;
            if (!email || email === 'undefined') {
                locals.send(400, { error: 'email address is invalid, check body' });
                return next();
            }
            if (!password || password === 'undefined') {
                locals.send(400, { error: 'password is invalid, check body' });
                return next();
            }
            let user;
            NativeAuthenticationAuthorityUser
                .getOne({
                [fields.emailDb]: email,
                [fields.domainDb]: domain
            })
                .then((existingUser) => {
                if (existingUser) {
                    locals.send(409, { error: 'email_in_use' });
                    throw 409;
                }
            })
                .then(() => bcrypt_1.hash(password, bcryptHashRounds))
                .then((pwHash) => {
                user = new NativeAuthenticationAuthorityUser();
                user.email = email;
                user.password = pwHash;
                user.domain = domain;
                user.emailVerified = false;
                user.passwordSet = new Date();
                if (customFields) {
                    for (const jsonField of Object.keys(customFields)) {
                        if (locals.reqBody[jsonField] === undefined) {
                            continue;
                        }
                        user[customFields[jsonField]] = locals.reqBody[jsonField];
                    }
                }
                user.passwordStrength = this.getPasswordStrength(password, user);
            })
                .then(() => user.create())
                .then(() => this.encryptToken({ userId: user.id }))
                .then((emailVerificationKey) => (options.onUserCreated && typeof options.onUserCreated === 'function')
                ? options.onUserCreated(user.toJson(), emailVerificationKey, req, res)
                : Promise.resolve())
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err === 409) {
                    return next();
                }
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    yield options.onError(err);
                }
                next();
            }));
        }
        emailVerification(req, res, next) {
            const locals = res.locals;
            Promise
                .resolve()
                .then(() => {
                const tokenParts = req.params.token.split('.');
                if (tokenParts && tokenParts.length !== 3) {
                    throw 403;
                }
                return tokenParts;
            })
                .then(this.decryptToken)
                .then((token) => NativeAuthenticationAuthorityUser.getById(token.userId, { [fields.emailVerifiedDb]: 1 }))
                .then((user) => {
                if (!user) {
                    throw 403;
                }
                if (!user.emailVerified) {
                    return user.save({ [fields.emailVerifiedDb]: true });
                }
            })
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err === 403) {
                    locals.send(403, { error: 'invalid_token' });
                    return next();
                }
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    yield options.onError(err);
                }
                return next();
            }));
        }
        forgotPassword(req, res, next) {
            const locals = res.locals;
            const email = `${locals.reqBody.email}`;
            const domain = `${locals.reqBody.domain || options.defaultDomain || nativeAuthConfig.defaultDomain}`;
            const query = {
                [fields.emailJson]: email,
                [fields.domainJson]: domain
            };
            let user;
            let token;
            let tokenHash;
            Promise
                .resolve()
                .then(() => {
                if (!locals.reqBody.email) {
                    return options
                        .onForgotPasswordEmailRequest(undefined, undefined, req, res)
                        .then(() => {
                        throw new Error('invalid');
                    });
                }
            })
                .then(() => NativeAuthenticationAuthorityUser.getOne(query))
                .then((usr) => user = usr)
                .then(() => (user)
                ? this.encryptToken({
                    issued: new Date().getTime(),
                    userId: user.id
                })
                : null)
                .then((tkn) => {
                if (!tkn) {
                    return;
                }
                token = tkn;
                tokenHash = this.hashToken(token);
                return user.save({ [fields.passwordResetHashDb]: tokenHash });
            })
                .then(() => options.onForgotPasswordEmailRequest(user, token, req, res))
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err === 'invalid') {
                    return next();
                }
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    yield options.onError(err);
                }
                next();
            }));
        }
        login(req, res, next) {
            const locals = res.locals;
            const email = `${locals.reqBody.email}`;
            const password = `${locals.reqBody.password}`;
            const domain = `${locals.reqBody.domain || options.defaultDomain || nativeAuthConfig.defaultDomain}`;
            if (!email || email === 'undefined') {
                locals.send(400, { error: 'email address is invalid, check body' });
                return next();
            }
            if (!password || password === 'undefined') {
                locals.send(400, { error: 'password is invalid, check body' });
                return next();
            }
            const query = {
                [fields.emailDb]: email,
                [fields.domainDb]: domain
            };
            let dbDoc;
            let userInfo;
            NativeAuthenticationAuthorityUser
                .getCursor(query)
                .limit(1)
                .next()
                .then((result) => {
                dbDoc = result;
                userInfo = NativeAuthenticationAuthorityUser.fromDb(dbDoc);
                if (!userInfo) {
                    locals.send(401, { error: 'login_failed' });
                    throw 401;
                }
            })
                .then(() => bcrypt_1.compare(password, userInfo.password))
                .then((pwMatch) => {
                if (!pwMatch) {
                    locals.send(401, { error: 'login_failed' });
                    throw 401;
                }
                if (!userInfo.emailVerified) {
                    locals.send(403, { error: 'email_validation_required' });
                    throw 403;
                }
                const payload = {
                    [fields.emailJson]: email,
                    [fields.domainJson]: domain
                };
                const fieldInclusion = ((sapi.config.authentication || {}).jwt || {}).fields;
                if (fieldInclusion) {
                    for (const dbbField of Object.keys(fieldInclusion)) {
                        const payloadField = fieldInclusion[dbbField];
                        if (typeof payloadField !== 'string') {
                            return Promise
                                .reject(new Error('unable to proceed, server misconfiguration. authentication.jwt.fields must be' +
                                `a key value pair of strings. key '${dbbField}' has a value typeof '${typeof payloadField}'`));
                        }
                        payload[payloadField] = dbDoc[dbbField];
                    }
                }
                if (options.onJWTPayloadInject) {
                    return options
                        .onJWTPayloadInject(payload, dbDoc)
                        .then((updatedPayload) => {
                        return updatedPayload;
                    });
                }
                else {
                    return payload;
                }
            })
                .then(buildJwtToken)
                .then((token) => __awaiter(this, void 0, void 0, function* () {
                return (options.onLoginSuccess)
                    ? new Promise((resolve, reject) => options
                        .onLoginSuccess(userInfo, token, sapi, req, res)
                        .then(() => resolve(token))
                        .catch((err) => {
                        reject(err);
                    }))
                    : Promise.resolve(token);
            }))
                .then((token) => locals.send(200, { token }))
                .then(() => userInfo.save({ [fields.lastLoginDb]: new Date() }))
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err.statusCode) {
                    locals.send(err.statusCode, { error: err.message });
                    return next();
                }
                if (err === 401 || err === 403) {
                    locals.status = err;
                    return next();
                }
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    yield options.onError(err);
                }
                return next();
            }));
            function buildJwtToken(payload) {
                const key = jwtAuthConfig.key;
                const issuer = jwtAuthConfig.issuer;
                const exp = jwtAuthConfig.exp || '48h';
                if (!key || key === '' || !issuer || issuer === '') {
                    return Promise
                        .reject(new Error(`Unable to proceed, server misconfiguration. 'authentication.jwt.key' length?: ` +
                        `'${key.length}' [note: value redacted for security], ` +
                        `authentication.jwt.issuer value?: '${issuer || '>VALUE MISSING<'}'. These are required fields.`));
                }
                const hmac = crypto_1.createHmac('sha256', key);
                hmac.update(JSON.stringify(payload));
                payload.issSig = hmac.digest('hex');
                const wait = [];
                const audiences = [];
                const jti = uuid_1.v4();
                wait.push(generateToken(key, issuer, issuer, exp, payload, jti));
                audiences.push(issuer);
                const audienceConfig = jwtAuthConfig.audiences;
                if (audienceConfig) {
                    for (const jwtAudience of Object.keys(audienceConfig)) {
                        const audienceKey = audienceConfig[jwtAudience];
                        if (typeof audienceKey !== 'string') {
                            return Promise.reject(new Error('Invalid authentication.jwt.audiences key defined. The value must be a '
                                + 'secret key in the form of a string.'));
                        }
                        wait.push(generateToken(audienceKey, issuer, jwtAudience, exp, payload, jti));
                        audiences.push(jwtAudience);
                    }
                }
                return Promise
                    .all(wait)
                    .then((jwtTokens) => {
                    const token = {};
                    let i = 0;
                    for (const result of jwtTokens) {
                        token[audiences[i]] = result;
                        i++;
                    }
                    return (() => (options.onInjectCustomToken)
                        ? options.onInjectCustomToken(token, key, issuer, exp, payload, jti)
                        : Promise.resolve([]))()
                        .then((customTokens) => {
                        const customTokensForLog = [];
                        for (const customToken of customTokens) {
                            token[customToken.audience] = customToken.token;
                            customTokensForLog.push({
                                audience: `${customToken.audience}`,
                                token: customToken.unEncodedToken || customToken.token
                            });
                        }
                        const logAuth = new AuthenticationLog();
                        logAuth.userId = userInfo.id;
                        logAuth.token = [{
                                audience: `${audiences.join(',')}`,
                                token: jsonwebtoken_1.decode(jwtTokens[0])
                            }, ...customTokensForLog];
                        logAuth.ip = req.ip;
                        logAuth.port = req.connection.remotePort;
                        logAuth.url = req.originalUrl;
                        logAuth.hostName = req.hostname;
                        logAuth.audience = audiences;
                        logAuth.jwTokenId = jti;
                        logAuth.created = new Date();
                        return logAuth
                            .create()
                            .then(() => {
                            return token;
                        });
                    });
                });
            }
            function generateToken(key, issuer, audience, exp, payload, jti) {
                return new Promise((resolve, reject) => {
                    jsonwebtoken_1.sign(payload, key, {
                        audience,
                        expiresIn: exp,
                        issuer,
                        jwtid: jti
                    }, (err, token) => {
                        if (err) {
                            reject(err);
                        }
                        resolve(token);
                    });
                });
            }
        }
        newEmailVerificationKey(req, res, next) {
            const locals = res.locals;
            const email = `${locals.reqBody.email}`;
            const password = `${locals.reqBody.password}`;
            const domain = `${locals.reqBody.domain || options.defaultDomain || nativeAuthConfig.defaultDomain}`;
            const query = {
                [fields.emailJson]: email,
                [fields.domainJson]: domain
            };
            let user;
            NativeAuthenticationAuthorityUser
                .getOne(query)
                .then((userFound) => {
                if (userFound) {
                    user = userFound;
                    return this.encryptToken({ userId: user.id });
                }
            })
                .then((key) => options.onResendEmailConfirmation(user, key, req, res))
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    options.onError(err);
                }
                next();
            }));
        }
        resetPassword(req, res, next) {
            const locals = res.locals;
            const password = `${locals.reqBody.password}`;
            let user;
            let token;
            Promise
                .resolve()
                .then(() => {
                if (!locals.reqBody.password || typeof locals.reqBody.password !== 'string') {
                    throw 400;
                }
                const tokenParts = req.params.token.split('.');
                if (tokenParts && tokenParts.length !== 3) {
                    throw 403;
                }
                return tokenParts;
            })
                .then(this.decryptToken)
                .then((tkn) => {
                const elapsedTime = new Date().getTime() - tkn.issued;
                if (elapsedTime > 24 * 3600000) {
                    throw 403;
                }
                token = tkn;
            })
                .then(() => NativeAuthenticationAuthorityUser.getById(token.userId, {
                [fields.passwordDb]: 1,
                [fields.passwordResetHashDb]: 1
            }))
                .then((usr) => {
                if (!usr) {
                    throw 403;
                }
                if (usr[fields.passwordResetHashDb] !== this.hashToken(req.params.token)) {
                    throw 403;
                }
                user = usr;
            })
                .then(() => bcrypt_1.hash(password, bcryptHashRounds))
                .then((pwHash) => user.save({
                [fields.emailVerifiedDb]: true,
                [fields.passwordDb]: pwHash,
                [fields.passwordResetHashDb]: null,
                [fields.passwordSetDateDb]: new Date(),
                [fields.passwordStrengthDb]: pwStrength(password).score
            }))
                .then(() => next())
                .catch((err) => __awaiter(this, void 0, void 0, function* () {
                if (err === 400) {
                    locals.send(400, { error: 'bad_request' });
                    return next();
                }
                if (err === 403) {
                    locals.send(403, { error: 'invalid_token' });
                    return next();
                }
                locals.send(500, { error: 'internal_server_error' });
                if (options.onError) {
                    options.onError(err);
                }
                return next();
            }));
        }
        encryptToken(keyContent) {
            return new Promise((resolve, reject) => {
                try {
                    const iv = crypto_1.randomBytes(IV_LENGTH);
                    let cipher;
                    try {
                        cipher = crypto_1.createCipheriv('aes-256-gcm', jwtAuthConfig.key, iv);
                    }
                    catch (err) {
                        throw new Error(`Invalid JWT private key set in SakuraApi's authorization.jwt.key setting: ${err}`);
                    }
                    const emailKeyBuffer = Buffer.concat([
                        cipher.update(JSON.stringify(keyContent), 'utf8'),
                        cipher.final()
                    ]);
                    const emailKeyHMACBuffer = cipher.getAuthTag();
                    resolve(`${urlsafe_base64_1.encode(emailKeyBuffer)}.${urlsafe_base64_1.encode(emailKeyHMACBuffer)}.${urlsafe_base64_1.encode(iv)}`);
                }
                catch (err) {
                    reject(err);
                }
            });
        }
        decryptToken(tokenParts) {
            return new Promise((resolve, reject) => {
                const tokenBase64 = tokenParts[0];
                const hmacBase64 = tokenParts[1];
                const ivBase64 = tokenParts[2];
                if (!urlsafe_base64_1.validate(tokenBase64) || !urlsafe_base64_1.validate(hmacBase64) || !urlsafe_base64_1.validate(ivBase64)) {
                    return reject(403);
                }
                const encryptedToken = urlsafe_base64_1.decode(tokenBase64);
                const hmacBuffer = urlsafe_base64_1.decode(hmacBase64);
                const ivBuffer = urlsafe_base64_1.decode(ivBase64);
                let token;
                try {
                    const decipher = crypto_1.createDecipheriv('aes-256-gcm', jwtAuthConfig.key, ivBuffer);
                    decipher.setAuthTag(hmacBuffer);
                    const tokenBuffer = Buffer.concat([
                        decipher.update(encryptedToken),
                        decipher.final()
                    ]);
                    token = JSON.parse(tokenBuffer.toString('utf8'));
                    resolve(token);
                }
                catch (err) {
                    return reject(403);
                }
            });
        }
        hashToken(token) {
            return crypto_1.createHash('sha256').update(JSON.stringify(token)).digest('base64');
        }
        getPasswordStrength(password, user) {
            const cd = [];
            for (const key of Object.keys(user)) {
                const value = user[key];
                if (typeof value === 'string' && key !== 'password') {
                    cd.push(user[key]);
                }
            }
            const pwValue = ((password || {}).length > 99) ? password.substring(0, 99) : password;
            return pwStrength(pwValue, cd).score;
        }
    };
    __decorate([
        core_1.Route({
            authenticator: options.authenticator,
            method: 'put',
            path: endpoints.changePassword || 'auth/native/change-password'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "changePassword", null);
    __decorate([
        core_1.Route({
            before: options.onBeforeUserCreate,
            method: 'post', path: endpoints.create || 'auth/native'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "create", null);
    __decorate([
        core_1.Route({
            method: 'get',
            path: endpoints.emailVerification || 'auth/native/confirm/:token'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "emailVerification", null);
    __decorate([
        core_1.Route({
            method: 'put',
            path: endpoints.forgotPassword || 'auth/native/forgot-password'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "forgotPassword", null);
    __decorate([
        core_1.Route({
            method: 'post',
            path: endpoints.login || 'auth/native/login'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "login", null);
    __decorate([
        core_1.Route({
            method: 'post',
            path: endpoints.newEmailVerificationKey || 'auth/native/confirm'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "newEmailVerificationKey", null);
    __decorate([
        core_1.Route({
            method: 'put',
            path: endpoints.resetPassword || 'auth/native/reset-password/:token'
        }),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object, Object, Function]),
        __metadata("design:returntype", void 0)
    ], AuthenticationAuthorityApi.prototype, "resetPassword", null);
    AuthenticationAuthorityApi = __decorate([
        core_1.Routable({
            model: NativeAuthenticationAuthorityUser,
            suppressApi: true
        })
    ], AuthenticationAuthorityApi);
    return {
        models: [
            AuthenticationLog,
            NativeAuthenticationAuthorityUser
        ],
        routables: [
            AuthenticationAuthorityApi
        ]
    };
}
exports.addAuthenticationAuthority = addAuthenticationAuthority;
//# sourceMappingURL=authentication.js.map